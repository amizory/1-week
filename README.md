# Основы разработки ПО/Основы системного администрирования

* [Основные понятия](#основные-понятия)
* [Git](#git)
* [Языки программирования](#языки-программирования)
* [Тестирование](#тестирование)
* [Основы Linux](#base-linux)

## <a id="основные-понятия">Основные понятия</a>

```txt
1 - Жизненный цикл ПО.
2 - Роли в команде и кто за что отвечает.
3 - Agile, Scrum, Kanban.
4 - Системы контроля версий, основные функции.
```

### Notice-1

```txt
1 - Что такое SDLC?

->  Software Development Life Cycle 
    (жизненный цикл процесса разработки ПО "framework")
    Этапы:
    1. Планирование - Что мы хотим сделать?
        - Цели, задачи, роли, обязанности, бюджет, сроки.
    2. Анализ входных требований - Какие проблемы требуют решения?
        - Функциональные, нефункциональные, оценка рисков.
    3. Проектирование - Как мы добьемся наших целей?
        - Архитектура и дизайн ПО. Технологии и инструменты, технические требования, прототип.
    4. Реализация - Процесс создания продукта.
        - Пишем код, создание функционального ПО.
    5. Тестирование - Регулирование качества продукта.
        - Проверка функциональности, производительности, безопасности ПО.
    6. Развертывание - Регулирование финального продукта.
        - Развертывание в производственной среде. Настройка и конфигурация ПО.
    7. Поддержка и обновления
        - Исправление ошибок, добавление новых функций, обновление существующих.
```

```txt
2 - Какие есть модели SDLC?

->  Waterfall (Step-by-step), 
    Iterative, 
    Spiral (waterfall + iterative), 
    Agile-model, V-model, Scrum, Kanban.
```

```txt
3 - Чем отличается Agile от Waterfall?

->  Agile разбивается на небольшие, управляемые фрагменты - спринты/итерации. 
    Гибкость и корректируемость, в том числе ошибки. Постоянное взаимодействие - обратная связь. 
    Agile проект более неопределенен, нет постоянных четких требований. 
    Waterfall прямолинеен и следует четкой стратегии.
```

```txt
4 - Что такое DevOps?

->  Методология, которая объединяет разработку 
    программного обеспечения (Development) и 
    эксплуатацию (Operations) в единый процесс. Основная цель 
    DevOps - улучшить сотрудничество и автоматизацию между этими 
    двумя группами, чтобы ускорить выпуск программного обеспечения и 
    повысить его качество.

    Аспекты:
    - автоматизация
    - непрерывная интеграция/доставка
    - мониторинг/обратная связь
    - кооперация
    Достижение результатов:
    - скорость выпуска ПО
    - качество ПО
    - уменьшение ошибок и сбоев
    - повышения удовлетворенности пользователями
```

```txt
5 - За что отвечают в команде разработчик, тестировщик, проектный менеджер, 
    Devops-инженер (инженер по автоматизации), системный администратор (инженер по эксплуатации)?

->  1 - Разработчик
        - разработка ПО, написание кода, исправление ошибок, улучшение кода
        - работает над реализацией требований проекта, создает новые функции
        - код-ревью (высокое качество кода)
        - взаимодействие с DevOps (правильная работа ПО) и отделом тестирования
    2 - Тестировщик
        - тестирование ПО, обнаружение ошибок и дефектов 
        - создание тестовых сценариев, тест-кейсов-сценариев и отслеживание результатов
        - взаимодеиствует с разработчиком (исправление ошибок)
        - участвует в создании тестовой документации
    3 - Проектный менеджер
        - управление проектом, планирование, организация и контроль
        - определяет цели и задачи проекта, создает план проекта и отслеживание прогресса
        - контроль ресурсов (время, бюджет, персонал)
        - обеспечивает коммуникацию между персоналом, заказчиком и др. сторонами 
    4 - DevOps
        - автоматизация процессов разработки, тестирования и эксплуатации ПО
        - создание и поддерживание процессов CI/CD/CM
        - взаимодействие с тестировщиками
        - помогает с совместимостью и согласованием процессов
        - повышение качества и скорость выпуска ПО
    5 - Системный администратор
        - обеспечивает эксплуатацию и поддержку инфраструктуры программного обеспечения
        - управляет серверами, базами данных, сетями и другими системами
        - мониторит производительность и безопасность систем
        - выполняет обновления, исправления и настройку систем
```

```txt
6 - Какие проблемы совместной работы решают системы контроля версий 
    (Version Control Systems)?

->  1 - Конфликты при редактировании.
        Вероятность перезаписи файла, когда над ним одновременно работают
        несколько человек из команды. VCS сохраняет историю изменений, что
        позволяет работать над разными версиями файла.
    2 - Конфликт сохранения.
        Если кто из команды не сохранил свои изменения, то новая информация
        может быть удалена. Система контроля версий сохраняет все изменения
        сделанные участником процесса и позволяет восстановить любую итерацию
        файла. Стоит отметить возможность автоматического резервного копирования.
    3 - Конфликт изменений. 
        В зависимости от проекта над ним могут работать
        большое количество людей. Высока вероятность того, что различные отделы
        не будут понимать что было сделано или изменено другим отделом. VCS
        дает информацию об изменениях, авторах и другую информационную составляющую, 
        как пример это - причина какого-то исправления. 
    4 - Конфликты разнообразных версий.
        Часто в проекте существует множество отдельных сервисов, директорий,
        файлов и каждого из перечисленных элементов есть свои рабочие версии.
        Контроль версий дает управление, историю и возможность взаимодействовать с ними.
    5 - Конфликт доступа.
        При работе над проектом часто необходимо обращаться к другим компьютерам, 
        виртуальным машинам и т.д. VCS предоставляет доступ к
        информации из любого места.
    6 - Конфликт безопасности.
        VCS предполагает использование защищенных репозиториев контролируя
        доступ к файлам. 
```

### Intern-1

```txt
1 - Чем отличается Agile и Scrum?

->  Agile: 
    это методология, которая предполагает гибкую и адаптивную
    разработку программного обеспечения. 
    Она подходит для проектов, которые требуют быстрой и частой доставки новых функций, итеративный подход.

    Scrum: 
    это методология, фактически это конкретная реализация Agile-разработки, можно сказать 
    framework, который предполагает разработку программного обеспечения в коротких итерациях (спринтах 1-4 недели). 
    Scrum имеет четкие роли (Product Owner, Scrum Master, разработчики, Daily Scrum). 
    Разработка - тестирование - реализация. Она подходит для проектов, которые требуют 
    быстрой и частой доставки новых функций.

    Agile - обобщает, Scrum - конкретизирует.
```

```txt
2 - Чем отличается Kanban и Scrum?

->  Это 2 разных подхода к разработке и управлению ПО.
    Kanban - предполагает гибкий и адаптивный процесс разработки, а
    главное предполагает визуальное представление всего процесса (доска, потоки,
    колонки, лимиты), конечно kanban основан на agile, но не 
    имеет такой жесткой системы как scrum (роли, спринты и т.д).

    Kanban - гибкость и визуальное представление, Scrum - структурированный.
```

```txt
3 - За что отвечают в команде product owner, scrum-мастер, 
    Бизнес Аналитик, Системный Аналитик, AQA, Архитектор ?

->  1 - Product Owner:
        - взаимодействие с бизнесом для определения требований и ожиданий
        - создает список требований к ПО
        - отвечает за определение и уровень важности требований к продукту
        - ответственный за включение, чего-то в следующий спринт
    2 - Scrum Master:
        - следит за исполнением принципов scrum
        - решение проблем и улучшения процесса
        - организует встречи, daily scrum, спринт планирование
        - организовывает коммуникацию между командой и заказчиками
    3 - Business Analyst
        - создание бизнес-кейсов, документации для поддержки требований
        - анализ бизнес-требований и определение требований к продукту
        - взаимодеиствует с бизнесом (заинтересованной стороной) для обозначений 
        бизнес-целей и будущих результатов
        - взаимодействие с product owner в определении и приоритетов требований
    4 - System Analyst
        - анализ технических требований и определение требований к системе
        - взаимодействие с разработчиками для определения технических возможностей 
        и ограничений
        - создание технической спецификации и другие документы поддержки требований
        - взаимодействие с product owner в определении и приоритетов требований
    5 - Automation quality assurance [аутомешейн кволити эшуранс]
        - автоматизация тестирования ПО
        - работа с командой разработки для определений требований к автоматическому 
        тестированию 
        - создание и поддержка автоматизированных тестов
        - помощь в обнаружение и ликвидации ошибок
    6 - Architect
        - определение архитектуры ПО
        - работа с командой разработки для определения технических возможностей 
        и ограничений
        - создание технических спецификаций и других документов поддержания архитектуры
        - помощь команде в принятие решений о технических аспектах ПО   
```

### Advanced-1

```txt
1 - Что такое Lean Development?

->  Линейная разработка - подход к разработке ПО (линейное производство и 
    управление). Минимизация потерь - максимизация ценности. Повышение 
    эффективности, качества продукта, а также его доставки. Удовлетворенности. 
    
    Принципы:
    - определение ценности - что является ценным для конечного потребителя?
    - определение flow - какой будет поток работы, процесса разработки?
    - минимизация потерь и неэффективных процессов
    - увеличение скорости - фактически CI/CD
    - разработка после открытия существенных фактов, а не на основе предложений
    - постоянное совершенствование

    Потери:
    - переработка
    - долгое ожидание ответов 
    - перемещение
    - перенасыщение
    - дефекты
    - нерациональное использование
    - неправильное проектирование

    Инструменты
    - kanban/scrum/kaizen
    - планирование/мониторинг

    Недостатки:
    - время на внедрение 
    - обучение 
    - сложность
    - может не подходить для проекта или команды
```

```txt
2 - За что отвечает в команде проектный координатор (на примере Aston)?

->  Отвечает за координацию и управление проектами, а также за обеспечение
    эффективного взаимодействия между членами команды и заинтересованными сторонами.
    - Планирование, организация, контроль выполнения проекта - координация.
    - Управление проектными ресурсами (время, команда, бюджет?)
    - Коммуникация между командой, заказчиком, клиентами.
    - Контроль качества - соответствие требованиям и стандартам компании.
    - Управления рисками и как они могут повлиять на проект (не допустить этого).
    - Отчеты о прогрессах, результатах, общий анализ.
    - Улучшение процессов - повышения качества и эффективности работы над проектом.
    - Ментальная атмосфера - возможность организации неформальных встреч для
    укрепления атмосферы в команде, устранение конфликтов.
```

```txt
3 - Может ли большая продуктовая команда построить эффективные процессы 
    разработки без системы контроля версий кода? Если да, то как? Если нет, то почему?

->  Да, возможно, но это будет очень сложно и неэффективно.
    - Хранение данных - облачные сервисы (~google drive/dropbox)
    - Управление проектом - Trello/Asana/Jira
    - Автоматизация - Jenkins
    - Методология - Kanban/Scrum

    Нет, потому что:
    - Конфликты при совместной работе с кодом.
    - Можно потерять данные при изменении кода.
    - Нет безопасности (доступ к данным). 
    - Малая автоматизация (сборка/тестирование)

    VCS дает:
    - версионирование
    - совместная работа
    - безопасность
    - автоматизация 
```

```txt
4 - Что такое SRE? Чем SRE отличается от DevOps?

->  Site Reliability Engineering - это подход к управлению и эксплуатации
    сложных систем, который сочетает в себе принципы инженерии и операций.

    Принципы:
    - надежность системы, минимальный простой
    - доступность системы, минимальный delay
    - производительность системы, минимальная обработка запроса
    - автоматизация/мониторинг

    Отличие:
    - sre - эксплуатация и управление системой
      devops - разработка и доставка ПО

    - sre - принцип инженерии и операций
      devops - принцип совместной работы и автоматизации

    - sre - роль инженера по надежности системы
      devops - роль разработчика и оператора

    - sre - цель - надежность и доступность системы
      devops - скорость и качество ПО

    Сходство:
    - автоматизация/мониторинг/коллективная работа/качество и
    надежность системы

```

## <a id="git">Git</a>

```txt
1 - Установка Git.
2 - Локальные и удалённые репозитории.
3 - Коммиты. Откат коммитов (reset, revert).
4 - Обмен изменениями с удалёнными репозиториями.
5 - Squash
6 - merge, rebase, cherry pick.
7 - Стратегии ветвления в Git.
```

### Notice-2

```txt
1 - Что такое локальный и удалённый репозитории в Git?

->  Репозиторий - это хранилище всех версий файлов и папок проекта,
    позволяющее отслеживать изменения и управлять историей разработки.
    Локальный репозиторий - это копия репозитория на вашем компьютере.
    Удалённый репозиторий - это копия репозитория на сервере (например, GitHub, GitLab).
```

```txt
2 - Как создать локальный репозиторий? Как создать удаленный репозиторий?

->  Локальный - git init
    Удаленный - сайт GitHub/GitLab/Bitbucket - create repo - name/description 
```

```txt
3 - Как добавить/удалить/изменить адрес удалённого репозитория?

->  git remote add <имя> <адрес> -> 
    git remote add origin https://github.com/username/repo.git
    
    git remote remove <имя> ->
    git remote remove origin
    
    git remote set-url <имя> <новый_адрес> ->
    git remote set-url origin https://github.com/username/new-repo.git
```

```txt
4 - Как скачать код из удалённого репозитория на локальную машину?

->  git clone <адрес_репозитория>
```

```txt
5 - Как зафиксировать свои изменения?

->  git add <файл> или git add .    -> Staged
    git commit -m 'message'         -> Tracked
```

```txt
6 - Как отправить код из локального репозитория в удаленный?

->  git push <имя_удаленного_репозитория> <ветка>
```

```txt
7 - Как создать новую ветку?

->  git branch <имя_ветки>/git checkout -b <имя_ветки>
```

```txt
8 - Как перейти на другую ветку?

->  git checkout <имя_ветки>
```

```txt
9 - Что такое .gitignore?


->  Это файл, в котором перечисляются файлы и папки, которые Git 
    должен игнорировать при отслеживании изменений.
    Примеры:
    1. #комментарии
    2. .file
    3. *.jpeg
    4. setting.pdf or !setting.pdf
    5. test/
```

```txt
10 - Как посмотреть историю коммитов (консоль)?

->  git log
    git log --oneline
    git log --graph
    git log -p 
    git shortlog
    git reflog
    git blame <имя_файла>
```

### Intern-2

```txt
1 - В чем отличие git reset от git revert?

->  RESET
    - удаляет коммит из истории репозитория
    - HEAD на предыдущий коммит
    - не создает новый коммит, а удаляет существующий

    REVERT
    - создает новый коммит, который отменяет действия предыдущего
    - не удаляет коммит из истории репозитория, а вместо этого 
    добавляет новый коммит, который отменяет изменения
    - изменяет указатель HEAD на новый коммит
```

```txt
2 - В чем отличие между git и GitHub (GitLab, BitBucket, etc)?

->  Git - если брать аналогию, директория на компьютере.
    Github - облако, где мы можем хранить файлы.
    Git - это инструмент для управления версиями кода на локальном компьютере 
    (отслеживание изменений в коде, создание локальных репозиториев, добавление, 
    коммиты, ветки), а GitHub (GitLab, BitBucket, etc.) - это веб-сервисы, 
    которые предоставляют хостинг для Git-репозиториев и позволяют вам 
    работать над кодом с другими разработчиками (удаленный репозиторий).

```

```txt
3 - Как подтянуть себе новые ветки из удалённого репозитория, не сливая их с локальными?

->  git fetch
    git fetch origin
    git fetch --all
    git checkout -t origin/new-branch
```

```txt
4 - Какие режимы работы есть у команды git reset и чем они отличаются?

->  Default
    git reset --mixed
    - rm commit in history
    - rm changes in file
    - rm changes in index

    Soft
    git reset --soft
    - rm commit in history
    - DON'T rm changes in file
    - changes in index

    HARD
    git reset --hard
    - rm commit in history
    - rm changes in file
    - rm changes in index and work dir

    --soft сохраняет изменения в файлах и индексе
    --mixed удаляет изменения в файлах, но сохраняет их в индексе
    --hard удаляет изменения в файлах, индексе и рабочей директории
```

```txt
5 - Что такое squash коммитов?

->  Процесс объединения нескольких коммитов в один коммит.
    git rebase -i
    Squash коммитов можно сделать только для коммитов, которые еще не 
    были отправлены в удаленный репозиторий
```

```txt
6 - Какие есть способы переноса коммитов из одной ветки в другую? 

->  1 - git checkout новая_ветка
        git cherry-pick коммит_из_старой_ветки
    
    2 - git checkout новая_ветка
        git rebase старая_ветка
    
    3 - git checkout новая_ветка
        git merge старая_ветка
    
    4 - git checkout новая_ветка
        git rebase -i старая_ветка

    5 - git format-patch старая_ветка
        git checkout новая_ветка
        git apply патч
    
    6 - git format-patch старая_ветка
        git checkout новая_ветка
        git am патч

        git format-patch -1 commit-id
        patch 0001-commit-message.patch
        git am 0001-commit-message.patch
```

```txt
7 - Чем отличается git merge от git rebase?

->  Merge - это команда, которая объединяет изменения из одной ветки в 
    другую, создавая новый коммит, который содержит все изменения из 
    обеих веток. Этот новый коммит называется "мердж-коммитом"

    Rebase - переписывает историю коммитов в текущей ветке, чтобы она 
    выглядела так, как если бы вы создали все коммиты в текущей ветке 
    после коммита из ветки, которую вы хотите объединить.
```

```txt
8 - Что такое .gitattributes? Что можно в него помещать?

->  .gitattributes — это файл в репозитории Git, который позволяет 
    указать атрибуты для файлов и папок.

    *.txt text eol=lf — указывает, что файлы с расширением .txt являются текстовыми и используют окончание строки LF

    *.jpg binary — указывает, что файлы с расширением .jpg являются бинарными

    *.py encoding=utf-8 — указывает, что файлы с расширением .py имеют 
    кодировку UTF-8

    *.md merge=union — указывает, что файлы с расширением .md должны 
    быть объединены с помощью стратегии union при слиянии.

    union: объединяет изменения из двух версий файла, сохраняя 
    все изменения.
    ours: сохраняет изменения из текущей ветки, игнорируя изменения 
    из другой ветки.
    theirs: сохраняет изменения из другой ветки, игнорируя 
    изменения из текущей ветки.
    binary: используется для бинарных файлов, сохраняет 
    изменения из текущей ветки.
    custom: позволяет указать пользовательскую стратегию слияния.   
```

```txt
9 - Как посмотреть разницу по конкретному файлу в двух разных ветках (консоль)?

->  git diff <ветка1>..<ветка2> -- <файл>

    git diff -b NAME_BRANCH..NAME_BRANCH --stat -- README.md
```

### Advanced-2

```txt
1 - Что такое interactive rebase, чем отличается от обычного?

->  Это режим rebasing в Git, который позволяет редактировать историю 
    коммитов перед применением их к новой ветке.
    git rebase -i HEAD~3
    pick - оставить коммит pick 123456 Commit 1
    squash - объединить с предыдущим squash 789012 Commit 2
    edit - редактировать коммит edit 345678 Commit 3
    drop - удалить коммит drop 901234 Commit 4
```

```txt
2 - В каких случае нужен git cherry pick?

->  Применяем отдельный коммит из другой ветки
    - Хочешь применить один коммит из другой ветки, не сливая всю ветку
    - Хочешь повторить коммит в другой ветке, без слияния
    - Хочешь исправить ошибку в другой ветке, без создания новой ветки
    - Хочешь перенести коммит из одной ветки в другую, после того, 
    как ветка уже была слита
    - Хочешь повторить коммит в другой ветке, после того, как коммит 
    был отменен (revert)
```

```txt
3 - Какая проблема при работе с git может возникнуть у команды если одна ее 
    часть работает на Linux (Mac), а другая на Windows? Как её решить?

->  Проблема: разные окончания строк в файлах (LF Linux/Mac vs CRLF Windows)
    1 - Windows - git config --global core.autocrlf input
    Git автоматически конвертировал CRLF в LF при коммите 
    2 - Linux/Mac - git config --global core.autocrlf false
    Сохранить LF
    3 - core.autocrlf в .gitattributes
    * eol=lf
    *.bat eol=crlf
    *.cmd eol=crlf
```

```txt
4 - Какие есть стратегии ветвления? Чем они отличаются между собой?

->  Centralized Workflow: одна основная ветка (master), 
    все изменения вносятся в нее (простая, но не гибкая)

    Feature Branch Workflow: создание отдельных веток для каждой 
    новой функции или задачи (гибкая, но требует больше управления ветками)

    Git Flow: расширенная стратегия, включающая несколько веток 
    (master, develop, feature, release, hotfix) (сложная, но позволяет 
    управлять сложными проектами)

    GitHub Flow: упрощенная стратегия, основанная на Feature Branch 
    Workflow, но с дополнительными правилами для pull request
    (гибкая, но требует использования pull request и code review)
```

```txt
5 - Как выбрать правильную стратегию ветвления под свой проект?

->  Размер команды: сколько разработчиков работает над проектом?
        Меньше 5: Centralized Workflow или Feature Branch Workflow
        Больше 5: Git Flow или GitHub Flow
    Сложность проекта: сколько функций и компонентов в проекте?
        Простой: Centralized Workflow или Feature Branch Workflow
        Сложный: Git Flow или GitHub Flow
    Частота релизов: как часто вы выпускаете новые версии проекта?
        Часто: GitHub Flow или Feature Branch Workflow
        Редко: Centralized Workflow или Git Flow
    Требования к управлению: нужен ли строгий контроль над 
    изменениями в проекте?
        Да: Git Flow или GitHub Flow
        Нет: Centralized Workflow или Feature Branch Workflow
    Опыт команды: есть ли у команды опыт работы с Git и ветвлением?
        Да: Git Flow или GitHub Flow
        Нет: Centralized Workflow или Feature Branch Workflow
```

## <a id="языки-программирования">Языки программирования</a>

```txt
1- Императивные и декларативные языки программирования (ЯП).
2 - Компилируемые и интерпретируемые ЯП.
3 - Слабо типизированные и сильно типизированные ЯП.
4 - Основные понятия ООП. 
```

### Notice-3

```txt
1 - Что такое императивный ЯП? Какие есть примеры?

->  Императивный язык программирования (ЯП) - это язык, в котором 
    программа описывается как последовательность команд, которые 
    выполняются в определённом порядке (явное указание что и как делать). 
    (C, C++, Java, Python, Ruby, PHP)  
```

```txt
2 - Что такое декларативный ЯП? Какие есть примеры?

->  Декларативный язык программирования (ЯП) - это язык, в котором 
    программа описывается как набор фактов и правил, которые определяют 
    желаемое поведение системы (нужно получить, а не как это получить)
    (SQL, HTML, CSS)
```

```txt
3 - Что такое компилируемый ЯП? Какие есть примеры?

->  Компилируемый язык программирования (ЯП) - это язык, который 
    перед выполнением программы компилируется в машинный код, который 
    может быть выполнен напрямую процессором компьютера.
    (C, C++, Fortran, Pascal, Assembly)
```

```txt
4 - Что такое интерпретируемый ЯП? Какие есть примеры?


->  Интерпретируемый язык программирования (ЯП) - это язык, который 
    не компилируется в машинный код, а вместо этого интерпретируется
    в режиме реального времени. Интерпретатор читает программу и 
    выполняет ее команды по одной за раз.
    (Python/Ruby/PHP/JavaScript/Perl)
```

```txt
5 - Java и С# относятся к компилируемым или интерпретируемым ?

->  Java и C# относятся к компилируемым языкам программирования, 
    но с некоторыми нюансами.

    Java компилируется в байт-код, который затем выполняется виртуальной машиной Java (JVM). 
    Java-код сначала компилируется в байт-код, а затем байт-код выполняется в JVM. 
    Таким образом, Java можно рассматривать как компилируемый язык с дополнительным слоем интерпретации.

    C# компилируется в промежуточный язык (IL), который затем выполняется виртуальной 
    машиной .NET (CLR). Это означает, что C#-код сначала компилируется в IL, 
    а затем IL выполняется в CLR. Таким образом, C# можно рассматривать как компилируемый 
    язык с дополнительным слоем интерпретации.

    В обоих случаях, Java и C# компилируются в промежуточный язык, который затем 
    выполняется виртуальной машиной. Это позволяет обеспечить платформенную 
    независимость и другие преимущества, но также добавляет слой интерпретации, 
    который может повлиять на производительность.

    Таким образом, можно сказать, что Java и C# являются компилируемыми языками с 
    элементами интерпретации.
```

### Intern-3

```txt
1 - Что означает слабо типизированный ЯП? Какие есть примеры?

->  Слабо типизированный язык программирования (ЯП) - это язык, который 
    не требует явного объявления типов переменных и позволяет использовать 
    переменные без указания их типов.
    (JavaScript/Python/Ruby/PHP/Perl)
```

```txt
2 - Что означает сильно типизированный ЯП? Какие есть примеры?

->  Сильно типизированный язык программирования (ЯП) - это язык, который
    требует явного объявления типов переменных и не допускает использования 
    переменных без указания их типов.
    (C/C++/Java/C#/Rust/Haskell)
```

```txt
3 - Что означает динамически типизированный ЯП? Какие есть примеры?

->  Динамически типизированный язык программирования (ЯП) - это язык,
    который не требует явного объявления типов переменных и позволяет определять 
    типы переменных во время выполнения программы.
    В динамически типизированных ЯП типы переменных определяются во 
    время выполнения программы, а не во время компиляции. Это означает, 
    что переменная может быть объявлена без указания ее 
    типа, и тип переменной будет определяться автоматически
    в зависимости от значения, которое ей присваивается.
    (JavaScript/Python/Ruby/PHP/Perl)
```

```txt
4 - Что означает статически типизированный ЯП? Какие есть примеры? 

->  Статически типизированный язык программирования (ЯП) - это язык, 
    который требует явного объявления типов переменных и определяет 
    типы переменных во время компиляции. В статически типизированных 
    ЯП типы переменных определяются во время компиляции, а не во 
    время выполнения программы. Это означает, что переменная должна 
    быть объявлена с указанием ее типа, и тип переменной не может 
    быть изменен после ее объявления.
    (C/C++/Java/C#/Rust/Haskell)
```

### Advanced-3

```txt
1 - Что такое ООП? Какие есть примеры ОО ЯП? 


->  ООП (Объектно-ориентированное программирование) - это парадигма
    программирования, которая основана на концепции объектов и классов.
    В ООП программы состоят из объектов, которые представляют 
    собой экземпляры классов. Классы определяют свойства и
    поведение объектов, а объекты наследуют свойства и 
    поведение своих классов.
    (Java/C++/C#/Python/Ruby/PHP)
```

```txt
2 - Какие основные принципы ООП и что каждый из них означает?

->  Основные принципы ООП:
    - Инкапсуляция: сокрытие внутренних деталей объекта от внешнего мира
    (объекты могут хранить свои данные и методы внутри себя, а доступ к ним можно 
    получить только через определенные интерфейсы)
    - Наследование: создание нового класса на основе существующего класса
    (новый класс может наследовать свойства и поведение существующего класса и 
    добавлять новые свойства и поведение)
    - Полиморфизм: возможность объекта принимать разные формы в зависимости от 
    контекста (объекты могут иметь разные методы с одинаковым именем, но с 
    разными параметрами)
    - Абстракция: представление сложных систем в упрощенной форме
    (означает, что объекты могут быть представлены как набор свойств и поведения, 
    без учета внутренних деталей.)
```

## <a id="тестирование">Тестирование</a>

```txt
1 - Цели тестирование ПО.
2 - Виды тестирования.
3 - Unit-тесты.
4 - Интеграционные тесты.
5 - Нагрузочное тестирование. 
```

### Notice-4

```txt
1 - Какие есть классификации тестов?

->  По цели:
    - Модульные тесты (unit testing): проверка отдельных 
    модулей или функций.
    - Интеграционные тесты (integration testing): проверка 
    взаимодействия между модулями.
    - Системные тесты (system testing): проверка всей 
    системы в целом.
    - Приемочные тесты (acceptance testing): проверка 
    соответствия системы требованиям.

    По уровню:
    - Юнит-тесты (unit testing): проверка отдельных 
    модулей или функций.
    - Интеграционные тесты (integration testing): проверка 
    взаимодействия между модулями.
    - Системные тесты (system testing): проверка всей 
    системы в целом.
    - Интерфейсные тесты (interface testing): проверка 
    взаимодействия между системами.

    По методу:
    - Ручные тесты (manual testing): проверка системы вручную.
    - Автоматические тесты (automated testing): проверка системы с помощью специального 
    программного обеспечения.

    По типу:
    - Функциональные тесты (functional testing): проверка 
    функциональности системы.
    - Нефункциональные тесты (non-functional testing): 
    проверка производительности, безопасности, удобства 
    использования и т.д.
    - Регрессионные тесты (regression testing): проверка 
    системы после внесения изменений.
    - Смоук-тесты (smoke testing): проверка системы на 
    наличие критических ошибок.
    - Устойчивые тесты (endurance testing): проверка 
    системы на устойчивость к нагрузке.
    - Нагрузочные тесты (load testing): проверка системы 
    на способность выдерживать высокую нагрузку.
    - Стресс-тесты (stress testing): проверка системы 
    на способность выдерживать экстремальную нагрузку.
```

### Intern-4

```txt
1 - Чем Unit-тесты отличаются от интеграционных?

->  Unit-тесты проверяют отдельные модули или функции в изоляции, 
    без зависимости от других частей системы. Они обычно проверяют правильность работы 
    конкретного кода, без учета внешних факторов.

    Интеграционные тесты, наоборот, проверяют взаимодействие 
    между несколькими модулями или системами, имитируя реальные 
    условия работы приложения. Они оценивают, как различные компоненты 
    системы работают вместе, обмениваются данными и реагируют на различные сценарии.
```

```txt
2 - Что такое автоматизированное тестирование? Чем отличается от классических Unit и 
    интеграционных тестов?

->  Автоматизированное тестирование отличается от классических
    Unit и интеграционных тестов тем, что оно не ограничивается 
    только проверкой отдельных модулей или взаимодействия между ними. Автоматизированное 
    тестирование может включать в себя:

    Функциональное тестирование: проверка того, что 
    приложение или система работают правильно и выполняют свои 
    функции.

    Регрессионное тестирование: проверка того, что изменения 
    в коде не повлияли на существующую функциональность.

    Тестирование пользовательского интерфейса: проверка того, 
    что пользовательский интерфейс работает правильно и 
    соответствует требованиям.

    Нагрузочное тестирование: проверка того, что приложение 
    или система могут выдержать большую нагрузку и количество 
    пользователей.
```

### Advanced-4

```txt
1 - Что такое нагрузочное тестирование? Как его проводить?

->  Нагрузочное тестирование (load testing) - это тип тестирования,
    который имитирует большую нагрузку на систему или приложение, 
    чтобы оценить ее производительность, стабильность и способность обрабатывать большое 
    количество запросов или пользователей.

    Цель нагрузочного тестирования - определить, как система 
    или приложение поведут себя при увеличении нагрузки, и выявить потенциальные проблемы, 
    такие как:

        Задержки в обработке запросов
        Ошибки и сбои
        Потеря данных
        Недостаточная производительность

    Чтобы провести нагрузочное тестирование, необходимо выполнить 
    следующие шаги:
    - Определить цели и задачи: Определить, что нужно тестировать, 
    и какие показатели производительности необходимо измерить.
    - Выбрать инструменты: Выбрать инструменты для нагрузочного 
    тестирования, такие как LoadView, Apache JMeter, Gatling, 
    LoadRunner, LoadNinja  или другие.
    - Создать тестовый сценарий: Создать тестовый сценарий, 
    который имитирует реальную нагрузку на систему или приложение.
    - Настроить тестовую среду: Настроить тестовую среду, 
    которая соответствует реальной среде, в которой работает 
    система или приложение.
    - Запустить тест: Запустить тест и имитировать нагрузку на 
    систему или приложение.
    - Анализировать результаты: Анализировать результаты теста 
    и выявлять потенциальные проблемы.
    - Оптимизировать систему: Оптимизировать систему или 
    приложение для улучшения производительности и стабильности.

    Нагрузочное тестирование можно проводить на различных 
    уровнях, включая:
    - Функциональное тестирование: Тестирование отдельных функций или компонентов системы.
    - Интеграционное тестирование: Тестирование взаимодействия между компонентами системы.
    - Системное тестирование: Тестирование всей системы или приложения.
```

## <a id="base-linux">Основы Linux</a>

```txt
1 - Понятия ядро ОС, дистрибутив, семейство дистрибутивов.
2 - Отличия между разными семействами и дистрибутивами (Debian-based, CentOS-based, Alpine и т.д.).
3 - Установка Linux.
4 - Форматы пакетов, пакетные менеджеры, управление репозиториями.
5 - Работа в консоли, основные команды, горячие клавиши, bash.
6 - Linux File Hierarchy Structure.
7 - Типы файлов, ссылки.
8 - Пользователи и группы.
9 - Права доступа в Linux, chmod, chown, umask.  
```

### Notice-5

```txt
1 - Что такое Linux? Что такое GNU/Linux.

->  Linux - ядро операционной системы, созданное Линусом Торвальдсом в 1991 году. 
    Оно управляет взаимодействием между аппаратным обеспечением и программными 
    приложениями.

    GNU/Linux - операционная система, основанная на ядре Linux и включающая в 
    себя набор утилит и программ из проекта GNU (GNU's Not Unix), созданного Ричардом 
    Столменом. GNU/Linux представляет собой полноценную операционную систему, которая
    включает в себя ядро Linux, системные утилиты, библиотеки и другие программы, 
    необходимые для работы компьютера.
```

```txt
2 - Что из себя представляет дистрибутив Linux?

->  Дистрибутив Linux - это сборка операционной системы GNU/Linux, включающая в себя ядро Linux, 
    системные утилиты, библиотеки, программы и другие компоненты, собранные вместе для 
    создания готовой к использованию операционной системы.

    Дистрибутив обычно включает в себя:
     - Ядро Linux
     - Системные утилиты (например, GNU Coreutils)
     - Пакетный менеджер (например, apt, yum)
     - Офисные программы (например, LibreOffice)
     - Браузер (например, Firefox)
     - Другие программы и утилиты
     - Примеры дистрибутивов Linux: Ubuntu, Debian, Fedora, CentOS, 
     openSUSE и многие другие.
```

```txt
3 - Чем могут отличаться различные дистрибутивы и семейства дистрибутивов?

->  Различные дистрибутивы и семейства дистрибутивов Linux могут отличаться по 
    следующим параметрам:

    Пакетный менеджер: Например, apt (Debian, Ubuntu), yum (Fedora, CentOS), 
    zypper (openSUSE).

    Семейство пакетов: Например, RPM (Red Hat, Fedora, CentOS), DEB (Debian, Ubuntu).

    Интерфейс пользователя: Например, GNOME (Ubuntu, Fedora), KDE (openSUSE, Kubuntu),
    XFCE (Xubuntu).

    Ядро Linux: Например, некоторые дистрибутивы могут использовать ядро Linux с
    патчами или модификациями.

    Цель использования: Например, дистрибутивы для серверов (CentOS, Ubuntu Server), 
    для десктопов (Ubuntu, Fedora), для встраиваемых систем (Yocto).

    Политика лицензирования: Например, некоторые дистрибутивы могут включать только свободное 
    программное обеспечение (Debian), а другие могут включать проприетарное ПО (Ubuntu).

    Поддержка оборудования: Например, некоторые дистрибутивы могут 
    иметь лучшую поддержку определённого оборудования (например, NVIDIA).

    Срок поддержки: Например, некоторые дистрибутивы могут иметь более длительный срок 
    поддержки (Ubuntu LTS), 
    а другие могут иметь более короткий срок поддержки (Fedora).

    Уровень сложности: Например, некоторые дистрибутивы могут быть более 
    простыми в использовании (Ubuntu), а другие могут быть более сложными (Gentoo).

    Сообщество и поддержка: Например, некоторые дистрибутивы могут иметь более крупное и
    активное сообщество (Ubuntu), а другие могут иметь более небольшое сообщество (Slackware).
    
    Примеры семейств дистрибутивов:
    - Debian (Debian, Ubuntu, Linux Mint)
    - Red Hat (Red Hat Enterprise Linux, CentOS, Fedora)
    - SUSE (openSUSE, SUSE Linux Enterprise Server)
    - Arch Linux (Arch Linux, Manjaro)
```

```txt
4 - Как установить пакет в debian-based дистрибутиве? Как установить пакет 
в rhel-based дистрибутиве?

->  sudo apt update -> Обновите список пакетов
    sudo apt install firefox

    sudo yum update (в RHEL 7 и ниже)
    sudo dnf update (в RHEL 8 и выше)
    sudo yum install firefox (в RHEL 7 и ниже)
    sudo dnf install firefox (в RHEL 8 и выше)
```

```txt
5 - Как посмотреть список директорий, в том числе скрытых? 

->  ls -a - список всех файлов и директорий в текущей директории, включая скрытые
    ls -ad - список только директорий в текущей директории, включая скрытые
    ls -aR - команда выведет список всех файлов и директорий в текущей 
    директории и всех поддиректориях, включая скрытые
```

```txt
6 - Как посмотреть сколько место в мегабайтах занимают файлы в директории? 

->  du -m
    du -ms
```

```txt
6 - Как посмотреть сколько место свободно на подключенных дисках?

->  df -h
    df -h --total
```

```txt
7 - Как передать вывод одной команды на ввод другой?

->  pipe -> command 1 | command 2 ---> cat file.txt | grep hello
    
```

```txt
8 - Как записать вывод команды в файл? Как записать только ошибки, 
которые вывела команда в файл? 
    
->  1 - redirect для записи вывода команды в файл ---> ls -l > file.txt
    2 - append для добавления вывода команды в конец файла ---> ls -l >> file.txt
    3 - ошибки ls -l несуществующая_директория 2> error.txt
```

```txt
9 - Что такое Exit Сode команды? Как его узнать? Какой Exit Сode 
соответствует успешному выполнению?

->  Exit Code команды - это целое число, которое возвращается командой 
    после ее выполнения. Этот код указывает на результат выполнения команды, 
    например, была ли команда успешно выполнена или произошла ошибка.

    ls -l
    echo $?
    0 - успех 
    2 - ошибка

    cp file1 file2 (если file1 - не существует)
    echo $?
    1 - означает, что команда была выполнена, но произошли некоторые проблемы 
    или предупреждения, которые не помешали выполнению команды.
```

```txt
10 - Что такое Linux File Hierarchy Structure ?

->  FHS - это стандартная структура файловой системы Linux, которая определяет, 
    где должны находиться различные файлы и директории в системе.
    FHS была разработана для обеспечения единой и логической организации файлов и 
    директорий в Linux-системах, что облегчает управление и поддержку системы.
    Основные директории FHS
    FHS определяет следующие основные директории:
    - / (корневая директория) - корень файловой системы
    - /bin - исполняемые файлы системных утилит
    - /boot - файлы загрузчика и ядра
    - /dev - файлы устройств
    - /etc - конфигурационные файлы системы
    - /home - домашние директории пользователей
    - /lib - библиотеки системных утилит
    - /media - точки монтирования для съемных устройств
    - /mnt - точки монтирования для временных файловых систем
    - /opt - дополнительные программы и данные
    - /proc - файлы, содержащие информацию о системе
    - /root - домашняя директория суперпользователя
    - /run - файлы, содержащие информацию о системе, созданные во время запуска
    - /sbin - исполняемые файлы системных утилит
    - /srv - данные серверных приложений
    - /sys - файлы, содержащие информацию о системе
    - /tmp - временные файлы
    - /usr - программы и данные пользователей
    - /var - переменные данные системы
    
    Каждая из этих директорий может иметь свои поддиректории,
    которые содержат дополнительные файлы и директории.
```

```txt
11 - Как создать нового пользователя в Linux?

->  useradd -m -s /bin/bash username
```

```txt
12 - Как изменить/удалить/добавить группу пользователю?

->  usermod -g группа username - change
    gpasswd -d username группа - удаление
    usermod -aG группа username - добавление
    groupadd группа
    groupdel группа
```

```txt
13 - Как устроена система разграничения прав доступа в Linux?

->  В Linux, система разграничения прав доступа основана 
    на концепции владельца файла, группы файла и прав доступа. 
    Каждый файл и директория в Linux имеет владельца, группу и 
    права доступа.
```

```txt
14 - Кто такой владелец файла? Что такое группа-владелец файла? 

->  Владелец файла - это пользователь, который создал файл или директория. 
    Владелец файла имеет полный контроль над файлом и может изменять права доступа.

    Группа-владелец файла - это группа пользователей, которой принадлежит файл
    или директория. Группа-владелец файла может быть одной из групп, которые 
    определены в системе.

    chown user2 example.txt
    chgrp group2 example.txt
```

```txt
15 - Как задавать права доступа в буквенном виде? Как задавать 
права доступа в числовом виде?

->  chmod a+r,ug+w,o-x file.txt
    r - 4 
    w - 2
    x - 1
    chmod 573 -> r-xrwx-wx
```

```txt
16 - Как поменять владельцев? Как поменять права на файл/директорию?

->  chown user1 file.txt
    chown -R user1:group1 dir/

    chmod 755 file.txt
    chmod -R u+w dir/
```

### Intern-5

```txt
1 - Какие Linux-дистрибутивы лучше подходят для Docker-образов? Почему?

->  - Alpine Linux: очень легкий (около 80 МБ), что делает его идеальным 
    для контейнеризации. Он также имеет простую и безопасную архитектуру.
    - Ubuntu: широко используемый и хорошо поддерживаемый дистрибутив 
    с большим количеством пакетов. Это делает его хорошим выбором для многих приложений.
    - CentOS: стабильный и надежный дистрибутив, основанный на 
    Red Hat Enterprise Linux. Он часто используется в производственных 
    средах и имеет хорошую поддержку пакетов.
```

```txt
2 - Как добавить новый репозиторий в пакетный менеджер?

->  Для apt (Ubuntu, Debian): sudo add-apt-repository <репозиторий>

    Для yum (CentOS, RHEL): sudo yum-config-manager --add-repo <репозиторий>

    Для dnf (Fedora): sudo dnf config-manager --add-repo <репозиторий>

    <репозиторий> === URL-адрес
```

```txt
3 - Как можно выполнить одну команду, только если предыдущая выполнилась успешно?

->  команда1 && команда2
    wget http://example.com/archive.zip && unzip archive.zip
```

```txt
4 - Как можно выполнить одну команду, только если предыдущая выполнилась неуспешно?

->  команда1 || команда2
    sudo service nginx start || echo "Ошибка"
```

```txt
5 - Какие есть типы ссылок в Linux? Чем они отличаются? 

->  Жесткие ссылки (hard links)
    ln file1 file2
    "Область пространства. Полноценный файл. Оригинал и ссылка изменяют
    друг друга." При удалении оригинала ссылки остаются. Одинаковый inode.

    Символические ссылки (soft links или symbolic links)
    ln -s file1 file2
    Фактически это ярлыки. При удалении файла ссылка не активна. Путь к файлу.
    Не указывают на тот же inode.
    
```

```txt
6 - Как создать ссылку на файл/директорию?

->  ln file1 file2
    ln -P /path/to/directory/ link (проблема цикличности ссылок)
    ln - file1 file2 (нельзя ссылаться на директорию выше)
    ln -s file1 file2
    ln -s /path/to/directory/ link
```

```txt
7 - Как создать нового пользователя в Linux из скрипта (non interactive mode)?

->  useradd -m -s /bin/bash -u 1001 -g other -c "new user" username
    1 -m home dir
    2 -s /bin/bash shell
    3 -u 1001 uid user
    4 -g other 
    5 -c "new user" commentary 
    
    adduser - требует интерактивного подхода
```

```txt
8 - Как поменять пароль пользователя?

->  passwd name-user
    passwd -f name-user (без запроса пароля)
    echo "qwerty12345" | passwd --stdin username
```

```txt
9 - Что означает execute бит на директории? 

->  dr-xr-xr-x
    Право на выполнение команд и программы внутри этой директории.
    Пользователь или группа имеет право доступа к файлам и поддерикториям
    внутри этой директории.

     - Выполнять команды и программы внутри директории
     - Переходить в поддиректории внутри директории
     - Читать и записывать файлы внутри директории, если у
    них есть соответствующие права доступа

    Бит чтения (r) позволяет затронутому пользователю просматривать 
    список файлов в каталоге.
    Бит записи (w) позволяет затронутому пользователю создавать, переименовывать или удалять файлы в каталоге, а также 
    изменять атрибуты каталога.
    Бит выполнения (x) позволяет затронутому пользователю войти 
    в каталог и получить доступ к файлам и каталогам внутри него.
```

```txt
10 - Какие минимальные права должны быть у директории и файла в ней чтобы пользователь-владелец мог его прочитать?

->  Для директории: r-x (чтение и выполнение)
    Для файла: r-- (чтение)
```

### Advanced-5

```txt
1 - Как осуществить процесс установки Linux на группу серверов в корпоративной сети?

->  - Посмотреть аппаратные возможности сервером (память, процессор)
    - Выбрать дистрибутив исходя из требований
    - Cobbler - инструмент для создания образа
    - PXE - инструмент развертывания, через протоколы DHCP/TFTP
    протокол для автоматической установки операционной системы
    - Ansible - инструмент для управления конфигурацией и настройки серверов
    - Тестируем 

    pxeboot -l /path/to/linux/installer -a /path/to/../file
```

```txt
2 - Как зафиксировать нужную версию пакета в системы, чтобы он не обновлялся автоматически?

->  - sudo apt-mark hold пакет
    - sudo apt-pinning пакет версия
    - sudo nano /etc/apt/preferences
    - sudo nano /etc/apt/sources.list
```

```txt
3 - Как можно самому собрать .deb или .rpm пакет?

->  Шаги для создания .deb пакета:
    - Создайте директорию для пакета.
    - Создайте файл debian/control с информацией о пакете.
    - Создайте файл debian/changelog с историей изменений 
    пакета.
    - Создайте директорию debian/ с файлами пакета.
    - Используйте инструмент dpkg-deb или debbuild для 
    создания .deb пакета.
    dpkg-deb --build директория
    или
    debbuild -us -uc -b директория

    Шаги для создания .rpm пакета:
    - Создайте директорию для пакета.
    - Создайте файл spec с информацией о пакете.
    - Создайте директорию BUILD/ с файлами пакета.
    - Используйте инструмент rpmbuild или mock для создания 
    .rpm пакета.

    rpmbuild -ba файл.spec
    mock -r файл.spec

```

```txt
4 - Как вывести в консоль размер всех файлов в текущей директории в отсортированном по убыванию виде?

-> du -h * | sort -h -r
```

```txt
5 - За что отвечают файлы /etc/sudoers, /etc/passwd, /etc/shadow ?

->  /etc/sudoers отвечает за управление правами доступа для команды sudo.
    Этот файл содержит список пользователей и групп, которые имеют право 
    использовать команду sudo для выполнения команд с правами суперпользователя.

    /etc/passwd содержит информацию о пользователях системы. Этот файл является 
    текстовым файлом, который содержит записи о каждом пользователе в следующем формате:

    NAME-PASS-UID-GID-FULL_NAME-HOMEDIR-SHELL

    /etc/shadow содержит информацию о паролях пользователей. Этот файл 
    является текстовым файлом, который содержит записи о каждом
    пользователе в следующем формате:

    имя:хеш-пароль:date last change :минимальная_дата_изменения_пароля:максимальная_дата_изменения_пароля:
    предупреждение_о_сроке_действия_пароля:срок_действия_пароля:резервное_поле
```

```txt
6 - Как разрешить пользователю выполнять все команды на хосте без ввода пароля?

->  1 - sudo visudo
    2 - файл /etc/sudoers
    3 - имя_пользователя ALL=(ALL) NOPASSWD:ALL

    1 - sudo usermod -aG sudo имя_пользователя
```

```txt
7 - Что такое sticky bit, suid, sgid? Где и зачем они применяются?

->  Sticky bit - это право доступа, которое позволяет только владельцу 
    файла или директории удалять или переименовывать файлы внутри 
    директории. Это право доступа обозначается как t в правах доступа 
    файла или директории.

    Sticky bit: часто используется на директориях /tmp и /var/tmp, 
    чтобы предотвратить удаление файлов другими пользователями.

    chmod +t /tmp

    Suid (Set User ID) - это право доступа, которое позволяет 
    программе выполняться с правами владельца файла, а не с правами 
    пользователя, который запускает программу. Это право доступа 
    обозначается как s в правах доступа файла.

    Suid: часто используется на программах, которые требуют повышенных
    прав доступа, таких как passwd, su и sudo.

    chmod +s /usr/bin/passwd
    -rwsr-xr-x 1 root root 12345 /usr/bin/passwd

    Sgid (Set Group ID) - это право доступа, которое позволяет 
    программе выполняться с правами группы владельца файла, а не 
    с правами группы пользователя, который запускает программу. Это 
    право доступа обозначается как s в правах доступа файла.

    Sgid: часто используется на программах, которые требуют доступа к 
    определенным группам, таких как groups и newgrp.

    chmod +s /usr/bin/groups
    -rwxr-sr-x 1 root users 12345 /usr/bin/groups
```
